# 정리 전

타입(데이터 타입이 아닌)
모든걸 타입으로? 사고를 타입으로 전환

형으로 역할 묘사
형을 통해 책임 표현
형을 통해 메시지 공유

여기서의 형은 참조타입
객체컨텍스트, 값컨텍스트
객체간 계약을 형을 통해 공유 - protocol, 마커인터페이스

enum.. 제네릭 사용 불가

this 관련된게 없으면 유틸리티?

상태에 대한 조건

외부에 분기를 위임하고 경우의 수만큼 처리기를 만드는 방식
if를 라이브러리에서 클라이언트로 이전
변화율에 따른 분기를 통해 격리

존채 가치가 곧 책임..
시스템의 존재가치는 사용자에게 제공되는 기능
사용자가 사용할 기능 = 시스템의 책임
시스템 차원의 책임을 더 작은 단위의 책임으로 분할

책임 - 워킹할 수 있는 함수
책임을 추상화하여 역할 정의(단순하게 여러개의 책임이 역할이 아님)

추상화는 위로 올라가지만 아래로 내려가기도 한다.
도메인 전문가가 된다? 회사를 좋아하면 된다

이프문 만큼의 객체..

케이스 간의 공통점을 찾는다

디비 정규화를 객체지향에?

클라이언트 코드 먼저. 

같은 시간 상영에  여러 영화...

먼저 시나리오대로 짜보고 그 다음에 클래스로?

형이 아니면 책임을 가질 수 없다.

이터레이터 수동적?
이터레이터는 내가 직접 제어하기 위해. has next...

discountCondintion.. 인터페이스

발동트리거, 액션..  분리가능
인터페이스의 기본은 메서드 하나?

1st. 인자없는 함수 2st. 인자 하나있는 함수
1st. 메서드 없는 인터페이스 2st. 메서드 하나 가진 인터페이스

모든 인자를 객체로.. 메세지
인자가 두개면 제대로 객체화가 되지 않았다?

진정한 역할은 역할 하나만 나타낸다.

제네릭. 상위경계, 하위경계

if 대신 implment.. 제네릭으로..

제네릭.. 라우터대신 jvm의 if로..

조건에 맞는 객체 생성..

list? set? 리스트 말고 셋?

알아야 하는 책임 = 권한?

valueObject
불변. 변하면 새겍체리턴.
c++ 스트럭쳐가 무조건 새겍체 리턴?
자바는 직접 만든다
